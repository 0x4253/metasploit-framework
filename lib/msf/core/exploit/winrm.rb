# -*- coding: binary -*-
require 'uri'
require 'digest'
require 'rex/proto/ntlm/crypt'
require 'rex/proto/ntlm/constants'
require 'rex/proto/ntlm/utils'
require 'rex/proto/ntlm/exceptions'
module Msf

  module Exploit::Remote::WinRM
    include Exploit::Remote::NTLM::Client
    include Exploit::Remote::HttpClient

    #
    # Constants
    #
    NTLM_CRYPT ||= Rex::Proto::NTLM::Crypt
    NTLM_CONST ||= Rex::Proto::NTLM::Constants
    NTLM_UTILS ||= Rex::Proto::NTLM::Utils
    NTLM_XCEPT ||= Rex::Proto::NTLM::Exceptions

    def initialize(info = {})
      super

      register_options(
        [
          Opt::RHOST,
          Opt::RPORT(5985),
          OptString.new('VHOST', [ false, "HTTP server virtual host" ]),
          Opt::Proxies
        ], self.class
      )

      register_advanced_options(
        [
          OptString.new('UserAgent', [false, 'The User-Agent header to use for all requests',
            Rex::Proto::Http::Client::DefaultUserAgent
            ]),
          OptString.new('BasicAuthUser', [false, 'The HTTP username to specify for basic authentication']),
          OptString.new('BasicAuthPass', [false, 'The HTTP password to specify for basic authentication']),
          OptString.new('DigestAuthUser', [false, 'The HTTP username to specify for digest authentication']),
          OptString.new('DigestAuthPassword', [false, 'The HTTP password to specify for digest authentication']),
          OptBool.new('DigestAuthIIS', [false, 'Conform to IIS, should work for most servers. Only set to false for non-IIS servers', true]),
          OptBool.new('SSL', [ false, 'Negotiate SSL for outgoing connections', false]),
          OptEnum.new('SSLVersion', [ false, 'Specify the version of SSL that should be used', 'SSL3', ['SSL2', 'SSL3', 'TLS1']]),
          OptBool.new('FingerprintCheck', [ false, 'Conduct a pre-exploit fingerprint verification', true]),
          OptString.new('DOMAIN', [ true, 'The domain to use for windows authentification', 'WORKSTATION'])
        ], self.class
      )

      register_evasion_options(
        [
          OptEnum.new('HTTP::uri_encode_mode', [false, 'Enable URI encoding', 'hex-normal', ['none', 'hex-normal', 'hex-all', 'hex-random', 'u-normal', 'u-all', 'u-random']]),
          OptBool.new('HTTP::uri_full_url', [false, 'Use the full URL for all HTTP requests', false]),
          OptInt.new('HTTP::pad_method_uri_count', [false, 'How many whitespace characters to use between the method and uri', 1]),
          OptInt.new('HTTP::pad_uri_version_count', [false, 'How many whitespace characters to use between the uri and version', 1]),
          OptEnum.new('HTTP::pad_method_uri_type', [false, 'What type of whitespace to use between the method and uri', 'space', ['space', 'tab', 'apache']]),
          OptEnum.new('HTTP::pad_uri_version_type', [false, 'What type of whitespace to use between the uri and version', 'space', ['space', 'tab', 'apache']]),
          OptBool.new('HTTP::method_random_valid', [false, 'Use a random, but valid, HTTP method for request', false]),
          OptBool.new('HTTP::method_random_invalid', [false, 'Use a random invalid, HTTP method for request', false]),
          OptBool.new('HTTP::method_random_case', [false, 'Use random casing for the HTTP method', false]),
          OptBool.new('HTTP::uri_dir_self_reference', [false, 'Insert self-referential directories into the uri', false]),
          OptBool.new('HTTP::uri_dir_fake_relative', [false, 'Insert fake relative directories into the uri', false]),
          OptBool.new('HTTP::uri_use_backslashes', [false, 'Use back slashes instead of forward slashes in the uri ', false]),
          OptBool.new('HTTP::pad_fake_headers', [false, 'Insert random, fake headers into the HTTP request', false]),
          OptInt.new('HTTP::pad_fake_headers_count', [false, 'How many fake headers to insert into the HTTP request', 0]),
          OptBool.new('HTTP::pad_get_params', [false, 'Insert random, fake query string variables into the request', false]),
          OptInt.new('HTTP::pad_get_params_count', [false, 'How many fake query string variables to insert into the request', 16]),
          OptBool.new('HTTP::pad_post_params', [false, 'Insert random, fake post variables into the request', false]),
          OptInt.new('HTTP::pad_post_params_count', [false, 'How many fake post variables to insert into the request', 16]),
          OptBool.new('HTTP::uri_fake_end', [false, 'Add a fake end of URI (eg: /%20HTTP/1.0/../../)', false]),
          OptBool.new('HTTP::uri_fake_params_start', [false, 'Add a fake start of params to the URI (eg: /%3fa=b/../)', false]),
          OptBool.new('HTTP::header_folding', [false, 'Enable folding of HTTP headers', false])
        ], self.class)

      register_autofilter_ports([ 5985,5986 ])
      register_autofilter_services(%W{ winrm })
    end

    def poke(opts={}, timeout = 20)
      c = connect(opts)
      to = opts[:timeout] || timeout
      ctype = "application/soap+xml;charset=UTF-8"
      resp, c = send_request_cgi(opts.merge({
        'uri' => opts['uri'],
        'method' => 'POST',
        'ctype'     => ctype,
        'data'        => opts['data']
      }))
      return resp
    end

    def parse_auth_methods(resp)
      return nil unless resp.code == 401
      methods = []
      methods << "Negotiate" if resp.headers['WWW-Authenticate'].include? "Negotiate"
      methods << "Kerberos" if resp.headers['WWW-Authenticate'].include? "Kerberos"
      methods << "Basic" if resp.headers['WWW-Authenticate'].include? "Basic"
      return methods
    end


    def send_request_ntlm(opts={}, timeout = 20)
      ntlm_options = {
          :signing    => false,
          :usentlm2_session   => datastore['NTLM::UseNTLM2_session'],
          :use_ntlmv2     => datastore['NTLM::UseNTLMv2'],
          :send_lm    => datastore['NTLM::SendLM'],
          :send_ntlm    => datastore['NTLM::SendNTLM']
          }

      ntlmssp_flags = NTLM_UTILS.make_ntlm_flags(ntlm_options)
      workstation_name =  Rex::Text.rand_text_alpha(rand(8)+1)
      domain_name = datastore['DOMAIN']

      ntlm_message_1 = "NEGOTIATE " + Rex::Text::encode_base64(NTLM_UTILS::make_ntlmssp_blob_init( domain_name,
        workstation_name,
        ntlmssp_flags))
      to = opts[:timeout] || timeout
      begin
        c = connect(opts)

        ctype = "application/soap+xml;charset=UTF-8"

        # First request to get the challenge
        r = c.request_cgi(opts.merge({
          'uri' => opts['uri'],
          'method' => 'POST',
          'ctype'     => ctype,
          'headers' => { 'Authorization' => ntlm_message_1},
          'data'        => opts['data']
          }))
        resp = c.send_recv(r, to)
        unless resp.kind_of? Rex::Proto::Http::Response
          return [nil,nil]
        end
        return [nil,nil] if resp.code == 404
        return [nil,nil] unless resp.code == 401 && resp.headers['WWW-Authenticate']

        # Get the challenge and craft the response
        ntlm_challenge = resp.headers['WWW-Authenticate'].match(/NEGOTIATE ([A-Z0-9\x2b\x2f=]+)/i)[1]
        return [nil,nil] unless ntlm_challenge


        #old and simplier method but not compatible with windows 7/2008r2
        #ntlm_message_2 = Rex::Proto::NTLM::Message.decode64(ntlm_challenge)
        #ntlm_message_3 = ntlm_message_2.response( {:user => opts['username'],:password => opts['password']}, {:ntlmv2 => true})

        ntlm_message_2 = Rex::Text::decode_base64(ntlm_challenge)
        blob_data = NTLM_UTILS.parse_ntlm_type_2_blob(ntlm_message_2)

        challenge_key = blob_data[:challenge_key]
        server_ntlmssp_flags = blob_data[:server_ntlmssp_flags] #else should raise an error
        #netbios name
        default_name =  blob_data[:default_name] || ''
        #netbios domain
        default_domain = blob_data[:default_domain] || ''
        #dns name
        dns_host_name =  blob_data[:dns_host_name] || ''
        #dns domain
        dns_domain_name =  blob_data[:dns_domain_name] || ''
        #Client time
        chall_MsvAvTimestamp = blob_data[:chall_MsvAvTimestamp] || ''

        spnopt = {:use_spn => datastore['NTLM::SendSPN'], :name =>  self.rhost}

        resp_lm,
        resp_ntlm,
        client_challenge,
        ntlm_cli_challenge = NTLM_UTILS.create_lm_ntlm_responses(opts['username'], opts['password'], challenge_key,
          domain_name, default_name, default_domain,
          dns_host_name, dns_domain_name, chall_MsvAvTimestamp,
          spnopt, ntlm_options)

        ntlm_message_3 = NTLM_UTILS.make_ntlmssp_blob_auth(domain_name, workstation_name, opts['username'], 
          resp_lm, resp_ntlm, '', ntlmssp_flags)
        ntlm_message_3 = Rex::Text::encode_base64(ntlm_message_3)

        # Send the response
        r = c.request_cgi(opts.merge({
          'uri' => opts['uri'],
          'method' => 'POST',
          'ctype'     => ctype,
          'headers' => { 'Authorization' => "NEGOTIATE #{ntlm_message_3}"},
          'data'        => opts['data']
          }))
        resp = c.send_recv(r, to, true)
        unless resp.kind_of? Rex::Proto::Http::Response
          return [nil,nil]
        end
        return [nil,nil] if resp.code == 404
        return [resp,c]

      rescue ::Errno::EPIPE, ::Timeout::Error
      end
    end

 


  end

end
